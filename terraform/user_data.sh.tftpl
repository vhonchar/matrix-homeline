#!/bin/bash
set -euxo pipefail

############################################
# Basic OS update + prerequisites
############################################
export DEBIAN_FRONTEND=noninteractive

apt-get update
apt-get upgrade -y

apt-get install -y \
  ca-certificates \
  curl \
  gnupg \
  lsb-release \
  unzip \
  jq

############################################
# Install Docker Engine + Compose plugin
############################################

# Add Docker GPG key
install -m 0755 -d /etc/apt/keyrings
curl -fsSL https://download.docker.com/linux/ubuntu/gpg \
  | gpg --dearmor -o /etc/apt/keyrings/docker.gpg
chmod a+r /etc/apt/keyrings/docker.gpg

# Add Docker apt repository
echo \
  "deb [arch=$(dpkg --print-architecture) signed-by=/etc/apt/keyrings/docker.gpg] \
  https://download.docker.com/linux/ubuntu \
  $(lsb_release -cs) stable" \
  > /etc/apt/sources.list.d/docker.list

apt-get update

apt-get install -y \
  docker-ce \
  docker-ce-cli \
  containerd.io \
  docker-buildx-plugin \
  docker-compose-plugin \
  awscli \
  git

systemctl enable docker
systemctl start docker

# Allow ubuntu and ssm users to run docker without sudo (if present)
if id "ubuntu" &>/dev/null; then
  usermod -aG docker ubuntu
fi

usermod -aG docker ssm-user

############################################
# (Optional) Log SSM agent status, but do not fail bootstrap
############################################
systemctl --no-pager status amazon-ssm-agent || true
systemctl --no-pager status snap.amazon-ssm-agent.amazon-ssm-agent || true

############################################
# Mount and format EBS volume (safe on re-attach)
############################################

VOLUME_ID='${volume_id}'
MOUNT_PATH='${mount_path}'
LABEL='${label}'
FSTYPE='${fstype}'

vol_nodash="$${VOLUME_ID//-/}"
BYID="/dev/disk/by-id/nvme-Amazon_Elastic_Block_Store_$${vol_nodash}"

wait_for() {
  local dev="$1" timeout_s="$2" start now
  start="$(date +%s)"
  while true; do
    [ -b "$dev" ] && return 0
    now="$(date +%s)"
    if [ $((now - start)) -ge "$timeout_s" ]; then
      echo "Timed out waiting for $dev" >&2
      return 1
    fi
    sleep 2
  done
}

mkdir -p "$MOUNT_PATH"

echo "Waiting for $BYID..."
wait_for "$BYID" 300

# Determine whether a filesystem already exists.
existing_type="$(blkid -o value -s TYPE "$BYID" 2>/dev/null || true)"
existing_uuid="$(blkid -o value -s UUID "$BYID" 2>/dev/null || true)"
existing_label="$(blkid -o value -s LABEL "$BYID" 2>/dev/null || true)"

if [ -z "$existing_type" ]; then
  echo "No filesystem detected on $BYID; creating $FSTYPE with label $LABEL"
  case "$FSTYPE" in
    ext4) mkfs.ext4 -F -L "$LABEL" "$BYID" ;;
    xfs)  mkfs.xfs  -f -L "$LABEL" "$BYID" ;;
    *)    echo "Unsupported fstype: $FSTYPE" >&2; exit 1 ;;
  esac

  existing_type="$(blkid -o value -s TYPE "$BYID")"
  existing_uuid="$(blkid -o value -s UUID "$BYID")"
  existing_label="$(blkid -o value -s LABEL "$BYID" 2>/dev/null || true)"
else
  echo "Existing filesystem detected on $BYID: type=$existing_type uuid=${existing_uuid:-<none>} label=${existing_label:-<none>}"

  # Do not reformat on re-attach. If desired FSTYPE differs, keep the real one for fstab.
  if [ -n "$FSTYPE" ] && [ "$existing_type" != "$FSTYPE" ]; then
    echo "Note: requested fstype '$FSTYPE' differs from existing '$existing_type'; keeping existing type (no reformat)."
    FSTYPE="$existing_type"
  fi

  # Ensure LABEL is set to the expected value (safe; does not erase data).
  if [ -n "$LABEL" ] && [ "$existing_label" != "$LABEL" ]; then
    echo "Relabeling $BYID from '${existing_label:-<empty>}' to '$LABEL' (type=$existing_type)"
    case "$existing_type" in
      ext4) e2label "$BYID" "$LABEL" ;;
      xfs)  xfs_admin -L "$LABEL" "$BYID" ;;
      *)    echo "Cannot relabel filesystem type '$existing_type'" >&2 ;;
    esac
  fi

  existing_uuid="$(blkid -o value -s UUID "$BYID" 2>/dev/null || true)"
fi

# Persist mount using UUID (most stable across reboots/reattach).
if [ -z "$existing_uuid" ]; then
  echo "ERROR: Unable to determine UUID for $BYID" >&2
  exit 1
fi

if ! grep -Fq "UUID=$existing_uuid " /etc/fstab; then
  echo "UUID=$existing_uuid $MOUNT_PATH $FSTYPE defaults,nofail 0 2" >> /etc/fstab
fi

mountpoint -q "$MOUNT_PATH" || mount "$BYID" "$MOUNT_PATH"

############################################
# Write a marker to detect completion
############################################
echo "Bootstrap completed at $(date -Is)" > /var/log/user-data-bootstrap.done
