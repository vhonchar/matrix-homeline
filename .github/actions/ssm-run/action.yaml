name: "SSM Run Commands (sync)"
description: "Run shell commands on an EC2 instance via AWS SSM and wait for completion."
author: "your-org"

inputs:
  aws-region:
    description: "AWS region"
    required: true
  instance-id:
    description: "EC2 instance id"
    required: true

  # --- Mode A: Run shell commands (default) ---
  commands:
    description: |
      Multi-line shell commands to run (single SSM command execution).
      If neither `parameters` nor `parameters-json` are set, this action will run
      the commands via: bash -lc '<script>'
      Example:
        set -euo pipefail
        cd /opt/app
        source .env
        echo "$VAR"
    required: false

  # --- Mode B: Run a custom SSM document with parameters ---
  # Provide exactly one of `parameters` or `parameters-json`.
  parameters:
    description: "SSM parameters in AWS CLI shorthand (e.g. ScriptUrl=...,ScriptSha256=...)"
    required: false
  parameters-json:
    description: |
      SSM parameters as JSON map (recommended; handles special chars safely).
      Example:
        {"ScriptUrl":["https://..."],"ScriptSha256":["abcd..."]}
    required: false

  document-name:
    description: "SSM document name"
    required: false
    default: "AWS-RunShellScript"
  comment:
    description: "SSM comment/audit string"
    required: false
    default: "Run from GitHub Actions"
  timeout-seconds:
    description: "Max seconds to wait for completion"
    required: false
    default: "1200"
  poll-interval-seconds:
    description: "Polling interval"
    required: false
    default: "5"

outputs:
  command-id:
    description: "SSM command id"
    value: ${{ steps.run.outputs.command_id }}
  console-url:
    description: "AWS Console deep link to the SSM command"
    value: ${{ steps.run.outputs.console_url }}
  status:
    description: "Final SSM command status"
    value: ${{ steps.run.outputs.status }}
  stdout:
    description: "Command stdout (may be truncated by SSM)"
    value: ${{ steps.run.outputs.stdout }}
  stderr:
    description: "Command stderr (may be truncated by SSM)"
    value: ${{ steps.run.outputs.stderr }}

runs:
  using: "composite"
  steps:
    - id: run
      shell: bash
      env:
        AWS_REGION: ${{ inputs.aws-region }}
        INSTANCE_ID: ${{ inputs.instance-id }}
        DOCUMENT_NAME: ${{ inputs.document-name }}
        COMMENT: ${{ inputs.comment }}
        TIMEOUT_SECONDS: ${{ inputs.timeout-seconds }}
        POLL_INTERVAL_SECONDS: ${{ inputs.poll-interval-seconds }}
        COMMANDS_BLOCK: ${{ inputs.commands }}
        PARAMETERS_SHORTHAND: ${{ inputs.parameters }}
        PARAMETERS_JSON_INPUT: ${{ inputs.parameters-json }}
      run: |
        set -euo pipefail

        if ! command -v aws >/dev/null 2>&1; then
          echo "::error::AWS CLI not found. Use ubuntu-latest runner or install awscli."
          exit 1
        fi

        if ! command -v jq >/dev/null 2>&1; then
          echo "::error::jq not found. It's present on ubuntu-latest; otherwise install jq."
          exit 1
        fi

        # Choose execution mode:
        # - If parameters-json is set: run DOCUMENT_NAME with those parameters.
        # - Else if parameters (shorthand) is set: run DOCUMENT_NAME with shorthand parameters.
        # - Else: run COMMANDS_BLOCK under bash via AWS-RunShellScript-style {commands:["bash -lc ..."]}.

        if [[ -n "${PARAMETERS_JSON_INPUT:-}" && -n "${PARAMETERS_SHORTHAND:-}" ]]; then
          echo "::error::Provide only one of inputs.parameters or inputs.parameters-json (not both)."
          exit 1
        fi

        if [[ -n "${PARAMETERS_JSON_INPUT:-}" ]]; then
          PARAMETERS_ARG="$PARAMETERS_JSON_INPUT"
        elif [[ -n "${PARAMETERS_SHORTHAND:-}" ]]; then
          PARAMETERS_ARG="$PARAMETERS_SHORTHAND"
        else
          if [[ -z "${COMMANDS_BLOCK:-}" ]]; then
            echo "::error::No commands provided. Set inputs.commands for shell mode, or provide inputs.parameters / inputs.parameters-json for document mode."
            exit 1
          fi

          # Force execution in bash (not /bin/sh) so `source` works.
          # We wrap the entire multi-line block into a single: bash -lc '<script>' invocation.
          # jq @sh safely shell-escapes the whole script (including newlines).
          ESCAPED_SCRIPT="$(printf '%s' "$COMMANDS_BLOCK" | jq -Rs '@sh')"
          BASH_COMMAND="bash -lc $ESCAPED_SCRIPT"

          # Build the SSM parameters object as JSON. We pass a *single* command:
          #   ["bash -lc '<script>'"]
          PARAMETERS_ARG="$(jq -cn --arg cmd "$BASH_COMMAND" '{commands:[$cmd]}')"
          echo $PARAMETERS_ARG
        fi

        # Send command (single execution / single CommandId).
        COMMAND_ID="$(aws ssm send-command \
          --region "$AWS_REGION" \
          --document-name "$DOCUMENT_NAME" \
          --instance-ids "$INSTANCE_ID" \
          --comment "$COMMENT" \
          --parameters "$PARAMETERS_ARG" \
          --query "Command.CommandId" \
          --output text)"

        CONSOLE_URL="https://${AWS_REGION}.console.aws.amazon.com/systems-manager/run-command/${COMMAND_ID}?region=${AWS_REGION}"

        echo "SSM CommandId: $COMMAND_ID"
        echo "Console: $CONSOLE_URL"

        echo "command_id=$COMMAND_ID" >> "$GITHUB_OUTPUT"
        echo "console_url=$CONSOLE_URL" >> "$GITHUB_OUTPUT"

        # Wait for invocation to exist (eventual consistency) and then finish.
        deadline=$(( $(date +%s) + TIMEOUT_SECONDS ))
        STATUS=""

        while true; do
          now=$(date +%s)
          if (( now > deadline )); then
            echo "::error::Timed out waiting for SSM command to finish. Console: $CONSOLE_URL"
            echo "status=TimedOut" >> "$GITHUB_OUTPUT"
            exit 1
          fi

          # get-command-invocation is the most direct way to see status + output.
          # It may fail early if invocation not yet created, so we tolerate errors.
          STATUS="$(aws ssm get-command-invocation \
            --region "$AWS_REGION" \
            --command-id "$COMMAND_ID" \
            --instance-id "$INSTANCE_ID" \
            --query "Status" \
            --output text 2>/dev/null || true)"

          if [[ -z "${STATUS:-}" || "$STATUS" == "None" ]]; then
            sleep "$POLL_INTERVAL_SECONDS"
            continue
          fi

          echo "Status: $STATUS"

          case "$STATUS" in
            Pending|InProgress|Delayed)
              sleep "$POLL_INTERVAL_SECONDS"
              ;;
            Success|Failed|Cancelled|TimedOut)
              break
              ;;
            *)
              # Unknown status; keep waiting a bit
              sleep "$POLL_INTERVAL_SECONDS"
              ;;
          esac
        done

        # Fetch stdout/stderr (note: SSM output can be truncated).
        STDOUT="$(aws ssm get-command-invocation \
          --region "$AWS_REGION" \
          --command-id "$COMMAND_ID" \
          --instance-id "$INSTANCE_ID" \
          --query "StandardOutputContent" \
          --output text 2>/dev/null || true)"

        STDERR="$(aws ssm get-command-invocation \
          --region "$AWS_REGION" \
          --command-id "$COMMAND_ID" \
          --instance-id "$INSTANCE_ID" \
          --query "StandardErrorContent" \
          --output text 2>/dev/null || true)"

        # Outputs
        {
          echo "status=$STATUS"
          echo "stdout<<__SSM_STDOUT__"
          echo "$STDOUT"
          echo "__SSM_STDOUT__"
          echo "stderr<<__SSM_STDERR__"
          echo "$STDERR"
          echo "__SSM_STDERR__"
        } >> "$GITHUB_OUTPUT"

        # Surface output in logs (useful for live debugging).
        echo "----- STDOUT -----"
        echo "$STDOUT"
        echo "----- STDERR -----"
        echo "$STDERR"

        if [[ "$STATUS" != "Success" ]]; then
          echo "::error::SSM command finished with status $STATUS. Console: $CONSOLE_URL"
          exit 1
        fi
