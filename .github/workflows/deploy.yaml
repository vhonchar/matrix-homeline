name: Deploy

on:
  push:
    branches:
      - main
  workflow_dispatch: {}

permissions:
  id-token: write
  contents: read

env:
  AWS_REGION: eu-central-1
  SSM_ROLE_TO_ASSUME: arn:aws:iam::887016236946:role/github-terraform-matrix-homeline
  REPO_URL: ${{ github.server_url }}/${{ github.repository }}.git
  SSM_DEPLOY_COMMAND: matrix-homeline-deploy

jobs:
  terraform:
    runs-on: ubuntu-latest

    outputs:
      instance_id: ${{ steps.tf_out.outputs.instance_id }}
      public_ip: ${{ steps.tf_out.outputs.public_ip }}

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Set TF variables
        run: |
          echo "TF_IN_AUTOMATION=true" >> $GITHUB_ENV
          echo "TF_VAR_aws_region=${{ env.AWS_REGION }}" >> $GITHUB_ENV
          echo "TF_VAR_ssm_deploy_command=${{ env.SSM_DEPLOY_COMMAND }}" >> $GITHUB_ENV

      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: 1.9.0

      - name: Configure AWS credentials (OIDC)
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ env.SSM_ROLE_TO_ASSUME }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Terraform Init
        working-directory: ./terraform
        run: terraform init -input=false

      - name: Terraform Plan
        working-directory: ./terraform
        run: terraform plan -input=false

      - name: Terraform Apply
        working-directory: ./terraform
        run: terraform apply -input=false -auto-approve

      - name: Read Terraform outputs
        id: tf_out
        working-directory: ./terraform
        run: |
          echo "instance_id=$(terraform output -raw matrix_instance_id)" >> "$GITHUB_OUTPUT"
          echo "public_ip=$(terraform output -raw matrix_public_ip)" >> "$GITHUB_OUTPUT"

      - name: Publish Terraform outputs (Job Summary)
        run: |
          {
            echo "## Terraform Outputs"
            echo ""
            echo "| Key | Value |"
            echo "|---|---|"
            echo "| Instance ID | \`${{ steps.tf_out.outputs.instance_id }}\` |"
            echo "| Public IP | \`${{ steps.tf_out.outputs.public_ip }}\` |"
            echo ""
          } >> "$GITHUB_STEP_SUMMARY"

      - name: Wait for SSM to become available (max 5 minutes)
        shell: bash
        env:
          INSTANCE_ID: ${{ steps.tf_out.outputs.instance_id }}
        run: |
          set -euo pipefail

          aws ec2 wait instance-running --region "$AWS_REGION" --instance-ids "$INSTANCE_ID"

          for i in {1..20}; do   # 20 × 15s = 5 minutes
            STATUS=$(aws ssm describe-instance-information \
              --region "$AWS_REGION" \
              --filters "Key=InstanceIds,Values=$INSTANCE_ID" \
              --query "InstanceInformationList[0].PingStatus" \
              --output text || true)

            if [[ "$STATUS" == "Online" ]]; then
              echo "SSM is online for instance $INSTANCE_ID"
              exit 0
            fi

            echo "Waiting for SSM... (status=${STATUS:-none})"
            sleep 15
          done

          echo "Timed out waiting for SSM to become available."
          exit 1

  deploy:
    name: Deploy via SSM (live progress)
    runs-on: ubuntu-latest
    needs: terraform

    env:
      INSTANCE_ID: ${{ needs.terraform.outputs.instance_id }}
      REF: ${{ github.ref_name }}

    steps:
      - name: Configure AWS credentials (OIDC)
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ env.SSM_ROLE_TO_ASSUME }}
          aws-region: ${{ env.AWS_REGION }}

      # Optional but helpful when debugging / audit
      - name: Print context
        shell: bash
        run: |
          set -euo pipefail
          echo "Instance: $INSTANCE_ID"
          echo "Ref: $REF"
          echo "SSM Document: $SSM_DEPLOY_COMMAND"

      - name: Compute ScriptUrl + sha256 (from repo + ref_name)
        id: script
        shell: bash
        run: |
          set -euo pipefail

          # Compose raw GitHub URL from current repo + ref (branch or tag)
          # Example: https://raw.githubusercontent.com/<owner>/<repo>/<ref>/deploy.sh
          SCRIPT_URL="https://raw.githubusercontent.com/${GITHUB_REPOSITORY}/${REF}/deploy.sh"

          echo "ScriptUrl: $SCRIPT_URL"

          # Download once and compute sha256 locally (this is what we'll pass to SSM)
          curl -fsSL "$SCRIPT_URL" -o /tmp/deploy.sh
          SCRIPT_SHA256=$(sha256sum /tmp/deploy.sh | awk '{print $1}')

          echo "script_url=$SCRIPT_URL" >> "$GITHUB_OUTPUT"
          echo "script_sha256=$SCRIPT_SHA256" >> "$GITHUB_OUTPUT"

          {
            echo "## Script Integrity"
            echo ""
            echo "| Key | Value |"
            echo "|---|---|"
            echo "| ScriptUrl | \`$SCRIPT_URL\` |"
            echo "| ScriptSha256 | \`$SCRIPT_SHA256\` |"
            echo ""
          } >> "$GITHUB_STEP_SUMMARY"

      - name: Send deploy command via SSM
        id: ssm
        shell: bash
        env:
          SCRIPT_URL: ${{ steps.script.outputs.script_url }}
          SCRIPT_SHA256: ${{ steps.script.outputs.script_sha256 }}
        run: |
          set -euo pipefail

          echo "Using ScriptUrl: $SCRIPT_URL"
          echo "Using ScriptSha256: $SCRIPT_SHA256"

          # send-command does not wait; it returns a CommandId which we will track.
          COMMAND_ID=$(
            aws ssm send-command \
              --region "$AWS_REGION" \
              --document-name "$SSM_DEPLOY_COMMAND" \
              --instance-ids "$INSTANCE_ID" \
              --parameters "ScriptUrl=$SCRIPT_URL,ScriptSha256=$SCRIPT_SHA256" \
              --comment "matrix-homeline deploy from GitHub Actions" \
              --query "Command.CommandId" \
              --output text
          )

          echo "command_id=$COMMAND_ID" >> "$GITHUB_OUTPUT"
          echo "SSM CommandId: $COMMAND_ID"

          {
            echo "## SSM Deploy"
            echo ""
            echo "| Key | Value |"
            echo "|---|---|"
            echo "| Instance ID | \`$INSTANCE_ID\` |"
            echo "| Ref | \`$REF\` |"
            echo "| Document | \`$SSM_DEPLOY_COMMAND\` |"
            echo "| ScriptUrl | \`$SCRIPT_URL\` |"
            echo "| ScriptSha256 | \`$SCRIPT_SHA256\` |"
            echo "| Command ID | \`$COMMAND_ID\` |"
            echo ""
            echo "Note: You can view the command in AWS Console → Systems Manager → Run Command."
          } >> "$GITHUB_STEP_SUMMARY"

      - name: Track SSM command progress (poll + live output)
        shell: bash
        env:
          COMMAND_ID: ${{ steps.ssm.outputs.command_id }}
        run: |
          set -euo pipefail

          echo "Tracking SSM command $COMMAND_ID on instance $INSTANCE_ID"

          # Keep track of how much output we've already printed, to avoid spam.
          LAST_STDOUT_LEN=0
          LAST_STDERR_LEN=0

          # Up to ~20 minutes (120 * 10s)
          for i in {1..120}; do
            # Query status and response code (if any)
            STATUS=$(aws ssm get-command-invocation \
              --region "$AWS_REGION" \
              --command-id "$COMMAND_ID" \
              --instance-id "$INSTANCE_ID" \
              --query "Status" \
              --output text 2>/dev/null || true)

            RESPONSE_CODE=$(aws ssm get-command-invocation \
              --region "$AWS_REGION" \
              --command-id "$COMMAND_ID" \
              --instance-id "$INSTANCE_ID" \
              --query "ResponseCode" \
              --output text 2>/dev/null || true)

            STDOUT=$(aws ssm get-command-invocation \
              --region "$AWS_REGION" \
              --command-id "$COMMAND_ID" \
              --instance-id "$INSTANCE_ID" \
              --query "StandardOutputContent" \
              --output text 2>/dev/null || true)

            STDERR=$(aws ssm get-command-invocation \
              --region "$AWS_REGION" \
              --command-id "$COMMAND_ID" \
              --instance-id "$INSTANCE_ID" \
              --query "StandardErrorContent" \
              --output text 2>/dev/null || true)

            # Print only deltas (new content since last poll)
            STDOUT_LEN=${#STDOUT}
            STDERR_LEN=${#STDERR}

            if (( STDOUT_LEN > LAST_STDOUT_LEN )); then
              echo ""
              echo "----- STDOUT (delta) -----"
              printf "%s" "${STDOUT:LAST_STDOUT_LEN}"
              echo ""
              LAST_STDOUT_LEN=$STDOUT_LEN
            fi

            if (( STDERR_LEN > LAST_STDERR_LEN )); then
              echo ""
              echo "----- STDERR (delta) -----"
              printf "%s" "${STDERR:LAST_STDERR_LEN}"
              echo ""
              LAST_STDERR_LEN=$STDERR_LEN
            fi

            # Status handling
            case "$STATUS" in
              Success)
                echo ""
                echo "Deployment succeeded. ResponseCode=$RESPONSE_CODE"

                {
                  echo "## Deployment Result"
                  echo "- Status: **Success**"
                  echo "- ResponseCode: \`$RESPONSE_CODE\`"
                } >> "$GITHUB_STEP_SUMMARY"

                exit 0
                ;;

              Failed|Cancelled|TimedOut)
                echo ""
                echo "Deployment finished with status: $STATUS (ResponseCode=$RESPONSE_CODE)"
                echo ""
                echo "----- STDOUT (full) -----"
                echo "$STDOUT"
                echo ""
                echo "----- STDERR (full) -----"
                echo "$STDERR"

                {
                  echo "## Deployment Result"
                  echo "- Status: **$STATUS**"
                  echo "- ResponseCode: \`$RESPONSE_CODE\`"
                  echo ""
                  echo "### STDERR (truncated if large)"
                  echo "\`\`\`"
                  # Guard summary size; keep last 4000 chars.
                  echo "${STDERR: -4000}"
                  echo "\`\`\`"
                } >> "$GITHUB_STEP_SUMMARY"

                exit 1
                ;;

              InProgress|Pending|Delayed|"" )
                echo "Status: ${STATUS:-none} (poll $i/120)"
                sleep 10
                ;;

              *)
                echo "Status: $STATUS (poll $i/120)"
                sleep 10
                ;;
            esac
          done

          echo "Timed out waiting for deployment to finish."
          exit 1
