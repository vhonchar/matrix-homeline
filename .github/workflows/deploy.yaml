name: Deploy

on:
  push:
    branches:
      - main
  workflow_dispatch: {}

permissions:
  id-token: write
  contents: read

env:
  AWS_REGION: eu-central-1
  SSM_ROLE_TO_ASSUME: arn:aws:iam::887016236946:role/github-terraform-matrix-homeline
  REPO_URL: ${{ github.server_url }}/${{ github.repository }}.git
  SSM_DEPLOY_COMMAND: matrix-homeline-deploy
  PORKBUN_API_KEY: ${{ secrets.PORKBUN_API_KEY }}
  PORKBUN_API_SECRETE_KEY: ${{ secrets.PORKBUN_API_SECRETE_KEY }}
  ACME_EMAIL: ${{ secrets.ACME_EMAIL }}

jobs:
  terraform:
    runs-on: ubuntu-latest

    outputs:
      instance_id: ${{ steps.tf_out.outputs.instance_id }}
      public_ip: ${{ steps.tf_out.outputs.public_ip }}

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Set TF variables
        run: |
          echo "TF_IN_AUTOMATION=true" >> $GITHUB_ENV
          echo "TF_VAR_aws_region=${{ env.AWS_REGION }}" >> $GITHUB_ENV
          echo "TF_VAR_ssm_deploy_command=${{ env.SSM_DEPLOY_COMMAND }}" >> $GITHUB_ENV
          echo "TF_VAR_porkbun_api_key=${{ env.PORKBUN_API_KEY }}" >> $GITHUB_ENV
          echo "TF_VAR_porkbun_api_secrete_key=${{ env.PORKBUN_API_SECRETE_KEY }}" >> $GITHUB_ENV
          echo "TF_VAR_acme_email=${{ env.ACME_EMAIL }}" >> $GITHUB_ENV

      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: 1.9.0

      - name: Configure AWS credentials (OIDC)
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ env.SSM_ROLE_TO_ASSUME }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Terraform Init
        working-directory: ./terraform
        run: terraform init -input=false

      - name: Terraform Plan
        working-directory: ./terraform
        run: terraform plan -input=false -replace='aws_instance.matrix'

      - name: Terraform Apply
        working-directory: ./terraform
        run: terraform apply -input=false -auto-approve -replace='aws_instance.matrix'

      - name: Read Terraform outputs
        id: tf_out
        working-directory: ./terraform
        run: |
          echo "instance_id=$(terraform output -raw matrix_instance_id)" >> "$GITHUB_OUTPUT"
          echo "public_ip=$(terraform output -raw matrix_public_ip)" >> "$GITHUB_OUTPUT"

      - name: Publish Terraform outputs (Job Summary)
        run: |
          {
            echo "## Terraform Outputs"
            echo ""
            echo "| Key | Value |"
            echo "|---|---|"
            echo "| Instance ID | \`${{ steps.tf_out.outputs.instance_id }}\` |"
            echo "| Public IP | \`${{ steps.tf_out.outputs.public_ip }}\` |"
            echo ""
          } >> "$GITHUB_STEP_SUMMARY"

      - name: Wait for user-data bootstrap to finish (via SSM marker file)
        shell: bash
        env:
          INSTANCE_ID: ${{ steps.tf_out.outputs.instance_id }}
        run: |
          set -euo pipefail

          aws ec2 wait instance-running --region "$AWS_REGION" --instance-ids "$INSTANCE_ID"

          MARKER_FILE="/var/log/user-data-bootstrap.done"

          echo "Waiting for user-data to complete (marker: $MARKER_FILE) on $INSTANCE_ID"

          # Up to ~15 minutes (90 * 10s)
          for i in {1..90}; do
            # Try to run a tiny SSM command. If the instance isn't yet SSM-ready, send-command
            # will error or the invocation will remain Pending/Delayed.
            COMMAND_ID=$(aws ssm send-command \
              --region "$AWS_REGION" \
              --document-name "AWS-RunShellScript" \
              --instance-ids "$INSTANCE_ID" \
              --parameters "commands=test -s $MARKER_FILE" \
              --comment "Wait for user-data marker file" \
              --query "Command.CommandId" \
              --output text 2>/dev/null || true)

            if [[ -z "${COMMAND_ID:-}" || "$COMMAND_ID" == "None" ]]; then
              echo "SSM not ready yet (poll $i/90)"
              sleep 10
              continue
            fi

            # Poll this tiny command for completion (up to ~30s)
            for j in {1..6}; do
              STATUS=$(aws ssm get-command-invocation \
                --region "$AWS_REGION" \
                --command-id "$COMMAND_ID" \
                --instance-id "$INSTANCE_ID" \
                --query "Status" \
                --output text 2>/dev/null || true)

              case "$STATUS" in
                Success)
                  echo "User-data finished: marker exists and is non-empty."
                  exit 0
                  ;;
                Failed|Cancelled|TimedOut)
                  # Marker missing (or other failure). Keep waiting.
                  break
                  ;;
                Pending|InProgress|Delayed|""|None)
                  sleep 5
                  ;;
                *)
                  sleep 5
                  ;;
              esac
            done

            echo "Waiting for marker... (poll $i/90)"
            sleep 10
          done

          echo "Timed out waiting for user-data bootstrap marker file: $MARKER_FILE"
          exit 1

  deploy:
    name: Deploy via SSM (live progress)
    runs-on: ubuntu-latest
    needs: terraform

    env:
      INSTANCE_ID: ${{ needs.terraform.outputs.instance_id }}
      REF: ${{ github.ref_name }}

    steps:
      - name: Configure AWS credentials (OIDC)
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ env.SSM_ROLE_TO_ASSUME }}
          aws-region: ${{ env.AWS_REGION }}

      # Optional but helpful when debugging / audit
      - name: Print context
        shell: bash
        run: |
          set -euo pipefail
          echo "Instance: $INSTANCE_ID"
          echo "Ref: $REF"
          echo "SSM Document: $SSM_DEPLOY_COMMAND"

      - name: Compute ScriptUrl + sha256 (from repo + ref_name)
        id: script
        shell: bash
        run: |
          set -euo pipefail

          # Compose raw GitHub URL from current repo + ref (branch or tag)
          # Example: https://raw.githubusercontent.com/<owner>/<repo>/<ref>/deploy.sh
          SCRIPT_URL="https://raw.githubusercontent.com/${GITHUB_REPOSITORY}/${REF}/deploy.sh"

          echo "ScriptUrl: $SCRIPT_URL"

          # Download once and compute sha256 locally (this is what we'll pass to SSM)
          curl -fsSL "$SCRIPT_URL" -o /tmp/deploy.sh
          SCRIPT_SHA256=$(sha256sum /tmp/deploy.sh | awk '{print $1}')

          echo "script_url=$SCRIPT_URL" >> "$GITHUB_OUTPUT"
          echo "script_sha256=$SCRIPT_SHA256" >> "$GITHUB_OUTPUT"

          {
            echo "## Script Integrity"
            echo ""
            echo "| Key | Value |"
            echo "|---|---|"
            echo "| ScriptUrl | \`$SCRIPT_URL\` |"
            echo "| ScriptSha256 | \`$SCRIPT_SHA256\` |"
            echo ""
          } >> "$GITHUB_STEP_SUMMARY"

      - name: Send deploy command via SSM
        id: ssm
        shell: bash
        env:
          SCRIPT_URL: ${{ steps.script.outputs.script_url }}
          SCRIPT_SHA256: ${{ steps.script.outputs.script_sha256 }}
        run: |
          set -euo pipefail

          echo "Using ScriptUrl: $SCRIPT_URL"
          echo "Using ScriptSha256: $SCRIPT_SHA256"

          COMMAND_ID=$(aws ssm send-command \
            --region "$AWS_REGION" \
            --document-name "$SSM_DEPLOY_COMMAND" \
            --instance-ids "$INSTANCE_ID" \
            --parameters "ScriptUrl=$SCRIPT_URL,ScriptSha256=$SCRIPT_SHA256" \
            --comment "matrix-homeline deploy from GitHub Actions" \
            --query "Command.CommandId" \
            --output text)

          # AWS Console deep link (Run Command â†’ Command details)
          CONSOLE_URL="https://${AWS_REGION}.console.aws.amazon.com/systems-manager/run-command/${COMMAND_ID}?region=${AWS_REGION}"

          echo "command_id=$COMMAND_ID" >> "$GITHUB_OUTPUT"
          echo "console_url=$CONSOLE_URL" >> "$GITHUB_OUTPUT"

          echo "SSM CommandId: $COMMAND_ID"
          echo "Console: $CONSOLE_URL"

          {
            echo "## SSM Deploy"
            echo ""
            echo "| Key | Value |"
            echo "|---|---|"
            echo "| Instance ID | \`$INSTANCE_ID\` |"
            echo "| Ref | \`$REF\` |"
            echo "| Document | \`$SSM_DEPLOY_COMMAND\` |"
            echo "| ScriptUrl | \`$SCRIPT_URL\` |"
            echo "| ScriptSha256 | \`$SCRIPT_SHA256\` |"
            echo "| Command ID | \`$COMMAND_ID\` |"
            echo "| Console Link | $CONSOLE_URL |"
            echo ""
          } >> "$GITHUB_STEP_SUMMARY"

      - name: Track SSM command status
        shell: bash
        env:
          COMMAND_ID: ${{ steps.ssm.outputs.command_id }}
          CONSOLE_URL: ${{ steps.ssm.outputs.console_url }}
        run: |
          set -euo pipefail

          echo "Tracking SSM command $COMMAND_ID on instance $INSTANCE_ID"
          echo "Console: $CONSOLE_URL"

          # Poll list-commands for the overall command status.
          # Note: Run Command APIs are eventually consistent; initial polls may return empty.
          for i in {1..120}; do  # ~20 minutes (120 * 10s)
            STATUS=$(aws ssm list-commands \
              --region "$AWS_REGION" \
              --command-id "$COMMAND_ID" \
              --query "Commands[0].Status" \
              --output text 2>/dev/null || true)

            if [[ -z "${STATUS:-}" || "$STATUS" == "None" ]]; then
              echo "Status: none (poll $i/120)"
              sleep 10
              continue
            fi

            echo "Status: $STATUS (poll $i/120)"

            case "$STATUS" in
              Success)
                echo "Deployment succeeded."
                echo "Console: $CONSOLE_URL"
                {
                  echo "## Deployment Result"
                  echo "- Status: **Success**"
                  echo "- Console: $CONSOLE_URL"
                } >> "$GITHUB_STEP_SUMMARY"
                exit 0
                ;;
              Failed|Cancelled|TimedOut)
                echo "Deployment finished with status: $STATUS"
                echo "Console: $CONSOLE_URL"
                {
                  echo "## Deployment Result"
                  echo "- Status: **$STATUS**"
                  echo "- Console: $CONSOLE_URL"
                } >> "$GITHUB_STEP_SUMMARY"
                exit 1
                ;;
              Pending|InProgress|Delayed)
                sleep 10
                ;;
              *)
                # Unknown status; keep polling.
                sleep 10
                ;;
            esac
          done

          echo "Timed out waiting for deployment to finish."
          echo "Console: $CONSOLE_URL"
          {
            echo "## Deployment Result"
            echo "- Status: **TimedOut (polling)**"
            echo "- Console: $CONSOLE_URL"
          } >> "$GITHUB_STEP_SUMMARY"
          exit 1
